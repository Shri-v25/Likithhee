<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aesthetic Jigsaw Puzzle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Aesthetic Theme - Inspired by the clean, vibrant style of image_1.png */
        :root {
            --bg-color: #00cba9; /* Bright cyan background */
            --text-color: #ffffff;
            --accent-color: #ffeb3b;
            --puzzle-border: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px var(--shadow-color);
            animation: fadeInDown 1s ease-out;
        }

        p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            animation: fadeIn 1.5s ease-out;
        }

        /* Puzzle Container */
        #puzzle-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4x4 grid */
            width: 400px;
            height: 400px;
            border: 5px solid var(--puzzle-border);
            border-radius: 15px;
            box-shadow: 0 10px 30px var(--shadow-color);
            background-color: rgba(255, 255, 255, 0.1);
            padding: 5px;
            position: relative;
            animation: scaleIn 0.8s ease-out;
        }

        /* Jigsaw Piece Styling with Realistic Shapes */
        .jigsaw-piece {
            width: 100px;
            height: 100px;
            background-image: url('gift.jpeg'); /* REPLACE WITH YOUR IMAGE PATH */
            background-size: 400px 400px;
            position: absolute;
            cursor: grab;
            transition: all 0.3s ease-in-out;
            /* The clip-path creates the interlocking jigsaw shape, referenced from image_0.png */
            -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
            z-index: 1;
        }

        /* Define specific clip-paths for different piece types to make them interlock */
        /* These are simplified examples, a full set would be more complex */
        .piece-type-1 { clip-path: path('M0,0 L100,0 L100,75 C100,75 125,75 125,100 C125,125 100,125 100,125 L0,125 L0,0 Z'); } /* Right Tab */
        .piece-type-2 { clip-path: path('M0,0 L100,0 L100,100 L25,100 C25,100 25,125 0,125 C-25,125 -25,100 0,100 L0,0 Z'); } /* Bottom Slot */
        .piece-type-3 { clip-path: path('M25,0 C25,0 25,-25 0,-25 C-25,-25 -25,0 0,0 L100,0 L100,100 L0,100 L0,0 Z'); } /* Top Tab */
        .piece-type-4 { clip-path: path('M0,0 L75,0 C75,0 75,-25 100,-25 C125,-25 125,0 100,0 L100,100 L0,100 L0,0 Z'); } /* Left Slot */


        .jigsaw-piece:active {
            cursor: grabbing;
            z-index: 10;
            transform: scale(1.05);
            box-shadow: 0 5px 15px var(--shadow-color);
        }

        .jigsaw-piece.correct {
            z-index: 0;
            cursor: default;
            filter: brightness(1.1);
            /* Once placed, the clip-path can be simplified or removed for a cleaner look */
            clip-path: none !important; 
            border-radius: 0 !important;
            box-shadow: none !important;
        }

        /* Animations */
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes celebrate {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Celebration Message */
        #celebration-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background-color: var(--accent-color);
            color: #000;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 2rem;
            font-weight: bold;
            box-shadow: 0 10px 30px var(--shadow-color);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 20;
        }
        #celebration-message.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

    </style>
</head>
<body>

    <h1>Happy Birthday!</h1>
    <p>Drag the pieces to solve the puzzle and reveal your gift.</p>

    <div id="puzzle-container">
        </div>
    <div id="celebration-message">You Did It! ðŸŽ‰</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('puzzle-container');
            const celebrationMessage = document.getElementById('celebration-message');
            const gridSize = 4; // 4x4 grid
            const pieceSize = 100; // 100px x 100px
            let pieces = [];

            // Initialize pieces with correct positions
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    pieces.push({
                        correctRow: row,
                        correctCol: col,
                        currentTop: 0,
                        currentLeft: 0,
                        element: null
                    });
                }
            }

            // Shuffle pieces randomly within the container
            pieces.forEach(piece => {
                piece.currentTop = Math.floor(Math.random() * (gridSize * pieceSize - pieceSize));
                piece.currentLeft = Math.floor(Math.random() * (gridSize * pieceSize - pieceSize));
            });

            // Create and append piece elements
            pieces.forEach((piece, index) => {
                const pieceEl = document.createElement('div');
                pieceEl.classList.add('jigsaw-piece');
                
                // Assign a random "type" for the jigsaw shape
                const type = (index % 4) + 1;
                pieceEl.classList.add(`piece-type-${type}`);

                // Set background position to show the correct part of the image
                pieceEl.style.backgroundPosition = `-${piece.correctCol * pieceSize}px -${piece.correctRow * pieceSize}px`;
                
                // Set initial random position
                pieceEl.style.top = `${piece.currentTop}px`;
                pieceEl.style.left = `${piece.currentLeft}px`;
                
                piece.element = pieceEl;
                container.appendChild(pieceEl);

                // Make piece draggable
                makeDraggable(piece);
            });

            function makeDraggable(piece) {
                let isDragging = false;
                let startX, startY, startTop, startLeft;

                piece.element.addEventListener('mousedown', startDrag);
                piece.element.addEventListener('touchstart', startDrag, { passive: false });

                function startDrag(e) {
                    if (piece.element.classList.contains('correct')) return;
                    e.preventDefault();
                    isDragging = true;
                    startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    startY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                    startTop = parseInt(piece.element.style.top);
                    startLeft = parseInt(piece.element.style.left);
                    
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('touchmove', drag, { passive: false });
                    document.addEventListener('mouseup', endDrag);
                    document.addEventListener('touchend', endDrag);
                }

                function drag(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                    const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                    
                    const deltaX = clientX - startX;
                    const deltaY = clientY - startY;
                    
                    let newTop = startTop + deltaY;
                    let newLeft = startLeft + deltaX;

                    // Boundary checks
                    newTop = Math.max(0, Math.min(newTop, container.clientHeight - pieceSize));
                    newLeft = Math.max(0, Math.min(newLeft, container.clientWidth - pieceSize));

                    piece.element.style.top = `${newTop}px`;
                    piece.element.style.left = `${newLeft}px`;
                }

                function endDrag() {
                    isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('touchmove', drag);
                    document.removeEventListener('mouseup', endDrag);
                    document.removeEventListener('touchend', endDrag);
                    
                    checkPosition(piece);
                }
            }

            function checkPosition(piece) {
                const currentTop = parseInt(piece.element.style.top);
                const currentLeft = parseInt(piece.element.style.left);
                const correctTop = piece.correctRow * pieceSize;
                const correctLeft = piece.correctCol * pieceSize;
                
                // Snap to position if close enough (e.g., within 20px)
                if (Math.abs(currentTop - correctTop) < 20 && Math.abs(currentLeft - correctLeft) < 20) {
                    piece.element.style.top = `${correctTop}px`;
                    piece.element.style.left = `${correctLeft}px`;
                    piece.element.classList.add('correct');
                    // Disable dragging for correct pieces
                    piece.element.removeEventListener('mousedown', makeDraggable.startDrag);
                    piece.element.removeEventListener('touchstart', makeDraggable.startDrag);
                    
                    checkWin();
                }
            }

            function checkWin() {
                const correctPieces = document.querySelectorAll('.jigsaw-piece.correct');
                if (correctPieces.length === pieces.length) {
                    // All pieces are in place!
                    celebrationMessage.classList.add('show');
                    container.style.animation = 'celebrate 0.5s ease-in-out';
                    // Optional: You could reveal the full, un-puzzled image here
                }
            }
        });
    </script>
</body>
</html>
